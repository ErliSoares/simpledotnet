<#+
public class LinqToSqlEntityClassTemplate : CSharpTemplate
{
    private System.Collections.Generic.List<Association> associations;
    private System.Collections.Generic.List<Column> columns;
    private int dataMemberOrder;
    private bool tableHasPrimaryKey;
    private bool typeHasSerializableAssociation;
    public Type[] BaseTypes { get; set; }

	public Database Database { get; set; }

    public Table Table { get; set; }

    public Type Type { get; set; }

	protected override void OnRendering(System.EventArgs e)
	{
	    this.Output.File = this.Type.Name + ".generated.cs";
		base.OnRendering(e);
	}

    /// <summary>
    /// Generates a partial entity class for the specified <see cref="Type"/>
    /// </summary>
    protected override void RenderCore()
    {
        base.RenderCore();

        this.dataMemberOrder = 0;
        this.ParseTypeDefinition();
#>
namespace <#= this.Database.EntityNamespace #>
{
    using System;
    using System.ComponentModel;
    using System.Data.Linq;
    using System.Data.Linq.Mapping;
<#+
        this.PushIndent("    ");
        this.RenderUsingDirectives();
        this.WriteLine(string.Empty);
        this.RenderDataContractAttribute();
        this.RenderTableAttribute();
        this.RenderInheritanceMappingAttributes(this.Type);
        this.PopIndent();
#>
    <#= AccessModifier(this.Type) #> <#= InheritanceModifier(this.Type) #>partial class <#= this.Type.Name #><#= this.GetClassBase() #>
    {
<#+
        this.PushIndent("        ");
        this.columns.ForEach(this.RenderField);
        this.associations.ForEach(this.RenderField);
        this.RenderSerializationField();
        this.RenderConstructor();
        this.RenderPropertyChangeEvents();
        this.columns.ForEach(this.RenderProperty);
        this.associations.ForEach(this.RenderProperty);
        this.RenderPropertyChangeMethods();
        this.associations.ForEach(this.RenderEntitySetActionMethods);
        this.RenderExtensibilityMethods();
        this.RenderSerializationMethods();
        this.PopIndent();
#>
    }
}
<#+
    }

    /// <summary>
    /// Validates code generation parameters
    /// </summary>
    protected override void Validate()
    {
        if (this.BaseTypes == null)
        {
            this.BaseTypes = new Type[0];
        }

        foreach (Type baseType in this.BaseTypes)
        {
            if (baseType == null)
            {
                throw new TransformationException("BaseTypes items cannot be null");
            }
        }

        if (this.Database == null)
        {
            throw new TransformationException("Database property must be assigned");
        }

        if (string.IsNullOrEmpty(this.Database.EntityNamespace))
        {
            throw new TransformationException("EntityNamespace property of the Database object must be assigned");
        }

        if (this.Type == null)
        {
            throw new TransformationException("Type property must be assigned");
        }

        // Make sure Items array is not null so that we don't have to check every time
        if (this.Type.Items == null)
        {
            this.Type.Items = new object[0];
        }

        if (this.Table == null)
        {
            throw new TransformationException("Table property must be assigned");
        }
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="association"/>.
    /// </summary>
    private static string AccessModifier(Association association)
    {
        return ToCSharp(association.AccessModifier);
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="column"/>.
    /// </summary>
    private static string AccessModifier(Column column)
    {
        return ToCSharp(column.AccessModifier);
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="type"/>.
    /// </summary>
    private static string AccessModifier(Type type)
    {
        return ToCSharp(type.AccessModifier);
    }

    /// <summary>
    /// Converts built-in C# type name to a fully-qualified CLR type name
    /// </summary>
    private static string ClrTypeName(string typeName)
    {
        switch (string.Intern(typeName))
        {
            case "bool":     return "System.Boolean";
            case "byte":     return "System.Byte";
            case "sbyte":    return "System.SByte";
            case "char":     return "System.Char";
            case "decimal":  return "System.Decimal";
            case "double":   return "System.Double";
            case "float":    return "System.Single";
            case "int":      return "System.Int32";
            case "uint":     return "System.UInt32";
            case "long":     return "System.Int64";
            case "ulong":    return "System.UInt64";
            case "object":   return "System.Object";
            case "short":    return "System.Int16";
            case "ushort":   return "System.UInt16";
            case "string":   return "System.String";
            case "DateTime": return "System.DateTime";
            case "Binary":   return "System.Data.Linq.Binary";
            default:         return typeName;
        }
    }

    /// <summary>
    /// Converts a fully-qualified CLR type name to a built-in C# type name
    /// </summary>
    private static string CSharpTypeName(string typeName)
    {
        switch (string.Intern(typeName))
        {
            case "System.Boolean":          return "bool";
            case "System.Byte":             return "byte";
            case "System.SByte":            return "sbyte";
            case "System.Char":             return "char";
            case "System.Decimal":          return "decimal";
            case "System.Double":           return "double";
            case "System.Single":           return "float";
            case "System.Int32":            return "int";
            case "System.UInt32":           return "uint";
            case "System.Int64":            return "long";
            case "System.UInt64":           return "ulong";
            case "System.Object":           return "object";
            case "System.Int16":            return "short";
            case "System.UInt16":           return "ushort";
            case "System.String":           return "string";
            case "System.DateTime":         return "DateTime";
            case "System.Data.Linq.Binary": return "Binary";
            default:                        return typeName;
        }
    }

    /// <summary>
    ///    Returns field name for the specified <paramref name="association"/>
    /// </summary>
    private static string FieldName(Association association)
    {
        return FieldName(association.Member);
    }

    /// <summary>
    ///    Returns field name for the specified <paramref name="column"/>
    /// </summary>
    private static string FieldName(Column column)
    {
        if (!string.IsNullOrEmpty(column.Member))
            return FieldName(column.Member);
        else
            return FieldName(column.Name);
    }

    /// <summary>
    /// Returns an Association object that represents a foreign key which contains
    /// the specified <paramref name="column"/> or null, if the column is not a part
    /// of any foreign key.
    /// </summary>
    private Association FindForeignKey(Column column)
    {
        foreach (Association association in this.associations)
        {
            if (association.IsForeignKey && !string.IsNullOrEmpty(association.ThisKey))
            {
                string[] columnNames = association.ThisKey.Split(new char[]{',', ' '});
                if (Array.IndexOf(columnNames, PropertyName(column)) >= 0)
                {
                    return association;
                }
            }
        }

        return null;
    }
	

    /// <summary>
    /// Returns class-base specification of the entity class which may include base
    /// class and interfaces it implements.
    /// </summary>
    private string GetClassBase()
    {
        string classBase = string.Empty;

        if (this.BaseTypes.Length > 0)
        {
            classBase += this.BaseTypes[0].Name;
        }
        else if (this.tableHasPrimaryKey)
        {
            if (classBase.Length > 0)
            {
                classBase += ", ";
            }

            classBase += "INotifyPropertyChanging, INotifyPropertyChanged";
        }

        if (classBase.Length > 0)
            return " : " + classBase;

        return string.Empty;
    }

    /// <summary>
    /// Returns names of columns in the specified association key.
    /// </summary>
    private static string[] GetColumnNamesFromKey(string key)
    {
        if (key == null)
            return new string[0];
        else
            return key.Split(new char[] { ',', ' ' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    /// <summary>
    /// Returns <see cref="Column" /> from the <see cref="Type"/> or its <see cref="BaseTypes"/>
    /// with a matching property name or null.
    /// </summary>
    private Column FindColumn(string columnName)
    {
        Column column = FindColumn(this.Type, columnName);
        if (column != null)
        {
            return column;
        }

        foreach (Type type in this.BaseTypes)
        {
            column = FindColumn(type, columnName);
            if (column != null)
            {
                return column;
            }
        }

        return null;
    }

    /// <summary>
    /// Returns <see cref="Column" /> from the specified <paramref name="type"/>
    /// with a matching property name or null.
    /// </summary>
    private static Column FindColumn(Type type, string columnName)
    {
        foreach (object item in type.Items)
        {
            Column column = item as Column;
            if (column != null && PropertyName(column) == columnName)
            {
                return column;
            }
        }

        return null;
    }

    /// <summary>
    /// Returns matching association from the target type of the specified <paramref name="association"/>
    /// </summary>
    private Association FindOtherAssociation(Association association)
    {
        Type otherType = this.GetTypeByName(association.Type);
        for (var i = 0; i < otherType.Items.Length; i++)
        {
            Association otherAssociation = otherType.Items[i] as Association;
            if (otherAssociation != null &&
                this.Type.Name == otherAssociation.Type &&
                association.OtherKey == otherAssociation.ThisKey)
            {
                return otherAssociation;
            }
        }

        return null;
    }

    /// <summary>
    /// Tries to find a <see cref="Type"/> with the specified <paramref name="typeName"/>
    /// in the inheritance hierarchy that starts with the specified <paramref name="baseType"/>.
    /// </summary>
    private static Type FindTypeByName(Type baseType, string typeName)
    {
        if (baseType.Name == typeName)
        {
            return baseType;
        }

        if (baseType.Type1 != null)
        {
            foreach (Type childType in baseType.Type1)
            {
                Type matchingType = FindTypeByName(childType, typeName);
                if (matchingType != null)
                {
                    return matchingType;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Returns an array of <see cref="Column"/> object that represent the specified association key.
    /// </summary>
    private Column[] GetColumnsFromKey(string key)
    {
        string[] columnNames = GetColumnNamesFromKey(key);
        Column[] columns = new Column[columnNames.Length];
        for (var i = 0; i < columnNames.Length; i++)
        {
            columns[i] = this.FindColumn(columnNames[i]);
            if (columns[i] == null)
            {
                throw new TransformationException(
                    string.Format("Association key is invalid. Field \"{0}\" doesn't exist", columnNames[i]));
            }
        }

        return columns;
    }

    /// <summary>
    /// Returns a type with the specified <paramref name="typeName"/> defined in the
    /// current <see cref="Database"/>.
    /// </summary>
    private Type GetTypeByName(string typeName)
    {
        foreach (Table table in this.Database.Table)
        {
            Type type = FindTypeByName(table.Type, typeName);
            if (type != null)
            {
                return type;
            }
        }

        throw new TransformationException(string.Format("Type {0} doesn't exist.", typeName));
    }

    /// <summary>
    /// Returns inheritance modifier (virtual, override, etc.) for the specified <paramref name="association"/>
    /// </summary>
    private static string InheritanceModifier(Association association)
    {
        return ToCSharp(association.Modifier, association.ModifierSpecified);
    }

    /// <summary>
    /// Returns inheritance modifier (virtual, override, etc.) for the specified <paramref name="column"/>
    /// </summary>
    private static string InheritanceModifier(Column column)
    {
        return ToCSharp(column.Modifier, column.ModifierSpecified);
    }

    /// <summary>
    /// Returns inheritance modifier (abstract, sealed, etc.) for the specified <paramref name="type"/>
    /// </summary>
    private static string InheritanceModifier(Type type)
    {
        if (type.ModifierSpecified)
        {
            return type.Modifier.ToString().ToLower() + " ";
        }

        // When "None" was selected in the designer
        return string.Empty;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="type"/> should be serialized.
    /// </summary>
    private bool IsDataContract(Type type)
    {
        return this.Database.Serialization == SerializationMode.Unidirectional &&
            type.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="association"/> should be serialized.
    /// </summary>
    private bool IsDataMember(Association association)
    {
        return this.IsDataContract(this.Type) && association.IsForeignKey == false &&
            association.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="column"/> should be serialized.
    /// </summary>
    private bool IsDataMember(Column column)
    {
        return this.IsDataContract(this.Type) &&
            column.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="association"/> has cardinality
    /// of one, such as if the association object represents a parent entity or a child
    /// entity in a one-to-one relationship.
    /// </summary>
    private static bool IsEntityRef(Association association)
    {
        return association.IsForeignKey || (association.CardinalitySpecified && association.Cardinality == Cardinality.One);
    }

    /// <summary>
    /// Extracts frequently used objects, such as <see cref="Column"/> and <see cref="Association"/>
    /// from the type definition for quick access.
    /// </summary>
    private void ParseTypeDefinition()
    {
        // Prepare all associations and columns for quick access
        this.associations = new System.Collections.Generic.List<Association>();
        this.columns = new System.Collections.Generic.List<Column>();
        for (int i = 0; i < this.Type.Items.Length; i++)
        {
            Column column = this.Type.Items[i] as Column;
            if (column != null)
            {
                this.columns.Add(column);
                continue;
            }

            Association association = this.Type.Items[i] as Association;
            if (association != null)
            {
                this.associations.Add(association);
                continue;
            }
        }

        // Determine if the type has a serializable association
        this.typeHasSerializableAssociation = this.associations.Exists(this.IsDataMember);

        // Determine if table has primary key
        this.tableHasPrimaryKey = false;
        for (int i = 0; i < this.Table.Type.Items.Length; i++)
        {
            Column column = this.Table.Type.Items[i] as Column;
            if (column != null && column.IsPrimaryKey)
            {
                this.tableHasPrimaryKey = true;
                break;
            }
        }
    }

    /// <summary>
    /// Returns property name for the specified <paramref name="association"/>
    /// </summary>
    private static string PropertyName(Association association)
    {
        return PropertyName(association.Member);
    }

    /// <summary>
    /// Returns property name for the specified <paramref name="column"/>
    /// </summary>
    private static string PropertyName(Column column)
    {
        if (!string.IsNullOrEmpty(column.Member))
            return PropertyName(column.Member);
        else
            return PropertyName(column.Name);
    }

    /// <summary>
    /// Renders [Association(...)] attribute for a property
    /// </summary>
    private void RenderAssociationAttribute(Association association)
    {
        System.Collections.Generic.List<string> parameters = new System.Collections.Generic.List<string>();

        if (!string.IsNullOrEmpty(association.Name))
        {
            parameters.Add(string.Format("Name = \"{0}\"", association.Name));
        }

        if (!string.IsNullOrEmpty(FieldName(association)))
        {
            parameters.Add(string.Format("Storage = \"{0}\"", FieldName(association)));
        }

        if (!string.IsNullOrEmpty(association.ThisKey))
        {
            parameters.Add(string.Format("ThisKey = \"{0}\"", association.ThisKey));
        }

        if (!string.IsNullOrEmpty(association.OtherKey))
        {
            parameters.Add(string.Format("OtherKey = \"{0}\"", association.OtherKey));
        }

        if (!association.IsForeignKey && association.CardinalitySpecified && association.Cardinality == Cardinality.One)
        {
            parameters.Add("IsUnique = true");
        }

        if (association.IsForeignKey || association.IsForeignKeySpecified)
        {
            parameters.Add(string.Format("IsForeignKey = {0}", association.IsForeignKey.ToString().ToLower()));
        }

        if (association.DeleteOnNull || association.DeleteOnNullSpecified)
        {
            parameters.Add(string.Format("DeleteOnNull = {0}", association.DeleteOnNull.ToString().ToLower()));
        }

        if (!string.IsNullOrEmpty(association.DeleteRule))
        {
            parameters.Add(string.Format("DeleteRule = \"{0}\"", association.DeleteRule));
        }

        this.WriteLine("[Association({0})]", string.Join(", ", parameters.ToArray()));
    }

    /// <summary>
    /// Renders [Column(...)] attribute for a property
    /// </summary>
    private void RenderColumnAttribute(Column column)
    {
        System.Collections.Generic.List<string> parameters = new System.Collections.Generic.List<string>();

        if (!string.IsNullOrEmpty(column.Name))
        {
            parameters.Add(string.Format("Name = \"{0}\"", column.Name));
        }

        if (!string.IsNullOrEmpty(FieldName(column)))
        {
            parameters.Add(string.Format("Storage = \"{0}\"", FieldName(column)));
        }

        if (column.CanBeNull || column.CanBeNullSpecified)
        {
            parameters.Add(string.Format("CanBeNull = {0}", column.CanBeNull.ToString().ToLower()));
        }

        if (!string.IsNullOrEmpty(column.DbType))
        {
            parameters.Add(string.Format("DbType = \"{0}\"", column.DbType));
        }

        if (!string.IsNullOrEmpty(column.Expression))
        {
            parameters.Add(string.Format("Expression = \"{0}\"", column.Expression));
        }

        if (column.IsDbGenerated || column.IsDbGeneratedSpecified)
        {
            parameters.Add(string.Format("IsDbGenerated = {0}", column.IsDbGenerated.ToString().ToLower()));
        }

        if (column.IsDiscriminator || column.IsDiscriminatorSpecified)
        {
            parameters.Add(string.Format("IsDiscriminator = {0}", column.IsDiscriminator.ToString().ToLower()));
        }

        if (column.IsPrimaryKey || column.IsPrimaryKeySpecified)
        {
            parameters.Add(string.Format("IsPrimaryKey = {0}", column.IsPrimaryKey.ToString().ToLower()));
        }

        if (column.IsVersion || column.IsVersionSpecified)
        {
            parameters.Add(string.Format("IsVersion = {0}", column.IsVersion.ToString().ToLower()));
        }

        if (column.UpdateCheck != default(UpdateCheck))
        {
            parameters.Add(string.Format("UpdateCheck = UpdateCheck.{0}", column.UpdateCheck));
        }

        this.WriteLine("[Column({0})]", string.Join(", ", parameters.ToArray()));
    }

    /// <summary>
    /// Renders constructor of the entity class
    /// </summary>
    private void RenderConstructor()
    {
#>

public <#= this.Type.Name #>()
{
<#+
        foreach (Association association in this.associations)
        {
            if (IsEntityRef(association))
            {
#>
    this.<#= FieldName(association) #> = default(EntityRef<<#= association.Type #>>);
<#+
            }
            else
            {
#>
    this.<#= FieldName(association) #> = new EntitySet<<#= association.Type #>>(this.Attach<#= PropertyName(association) #>, this.Detach<#= PropertyName(association) #>);
<#+
            }
        }

        if (this.tableHasPrimaryKey)
        {
#>
    this.OnCreated();
<#+
        }
#>
}
<#+
    }

    /// <summary>
    /// Renders [DataContract] attribute for the entity class if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataContractAttribute()
    {
        if (this.IsDataContract(this.Type))
        {
            this.WriteLine("[DataContract]");
        }
    }

    /// <summary>
    /// Renders [DataMember] attribute for the association property if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataMemberAttribute(Association association)
    {
        if (this.IsDataMember(association))
        {
            this.WriteLine("[DataMember(Order = {0}, EmitDefaultValue = false)]", ++this.dataMemberOrder);
        }
    }

    /// <summary>
    /// Renders [DataMember] attribute for the column property if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataMemberAttribute(Column column)
    {
        if (this.IsDataMember(column))
        {
            this.WriteLine("[DataMember(Order = {0})]", ++this.dataMemberOrder);
        }
    }

    /// <summary>
    /// Renders partial extensibility methods of the entity class
    /// </summary>
    private void RenderExtensibilityMethods()
    {
        // MSLinqToSqlGenerator doesn't generate extensibility methods without primary key
        if (this.tableHasPrimaryKey)
        {
#>

#region Extensibility methods

partial void OnCreated();

partial void OnLoaded();

partial void OnValidate(ChangeAction action);
<#+
            foreach (Column column in this.columns)
            {
#>

partial void On<#= PropertyName(column) #>Changing(<#= TypeName(column) #> value);

partial void On<#= PropertyName(column) #>Changed();
<#+
            }
#>

#endregion
<#+
        }
    }

    /// <summary>
    /// Renders field declaration for the specified <paramref name="association"/>
    /// </summary>
    private void RenderField(Association association)
    {
        if (IsEntityRef(association))
        {
#>
private EntityRef<<#= association.Type #>> <#= FieldName(association) #>;
<#+
        }
        else
        {
#>
private EntitySet<<#= association.Type #>> <#= FieldName(association) #>;
<#+
        }
    }

    /// <summary>
    /// Renders field declaration for the specified <paramref name="column"/>
    /// </summary>
    private void RenderField(Column column)
    {
#>
private <#= TypeName(column) #> <#= FieldName(column) #>;
<#+
    }

    /// <summary>
    /// Renders [InheritanceMapping] attribute for the specified <paramref name="type"/>
    /// and all of its child types defined in the LINQ to SQL model.
    /// </summary>
    private void RenderInheritanceMappingAttributes(Type type)
    {
        if (this.BaseTypes.Length == 0)
        {
            if (!string.IsNullOrEmpty(type.InheritanceCode))
            {
                this.Write("[InheritanceMapping(Code={0}, Type=typeof({1})", type.InheritanceCode, type.Name);
                if (type.IsInheritanceDefault)
                    this.Write(", IsDefault=true");
                this.WriteLine(")]");
            }

            if (type.Type1 != null)
            {
                Array.ForEach(type.Type1, this.RenderInheritanceMappingAttributes);
            }
        }
    }

    /// <summary>
    /// Renders property for a Many-To-One or a One-To-One association
    /// </summary>
    private void RenderEntityRefProperty(Association association)
    {
        Column[] thisKeyColumns = this.GetColumnsFromKey(association.ThisKey);
        string[] otherKeyColumnNames = GetColumnNamesFromKey(association.OtherKey);
        if (thisKeyColumns.Length != otherKeyColumnNames.Length)
        {
            throw new TransformationException(string.Format(
                "Invalid association. Number of columns in ThisKey ({0}) and OtherKey ({1}) doesn't match",
                association.ThisKey, association.OtherKey));
        }

        Association otherAssociation = this.FindOtherAssociation(association);
        bool otherAssociationIsEntityRef = (otherAssociation != null) &&
            (otherAssociation.IsForeignKey || (otherAssociation.CardinalitySpecified && otherAssociation.Cardinality == Cardinality.One));
#>
<#= AccessModifier(association) #> <#= InheritanceModifier(association) #><#= association.Type #> <#= PropertyName(association) #>
{
    get
    {
        return this.<#= FieldName(association) #>.Entity;
    }

    set
    {
        <#= association.Type #> previousValue = this.<#= FieldName(association) #>.Entity;
        if (previousValue != value || !this.<#= FieldName(association) #>.HasLoadedOrAssignedValue)
        {
            this.SendPropertyChanging("<#= PropertyName(association) #>");
<#+
            if (otherAssociation != null)
            {
#>

            if (previousValue != null)
            {
                this.<#= FieldName(association) #>.Entity = null;
<#+
                if (otherAssociationIsEntityRef)
                {
#>
                previousValue.<#= PropertyName(otherAssociation) #> = null;
<#+
                }
                else
                {
#>
                previousValue.<#= PropertyName(otherAssociation) #>.Remove(this);
<#+
                }
#>
            }

<#+
            }
#>
            this.<#= FieldName(association) #>.Entity = value;
<#+
            if (otherAssociation != null)
            {
#>

            if (value != null)
            {
<#+
                if (otherAssociationIsEntityRef)
                {
#>
                value.<#= PropertyName(otherAssociation) #> = this;
<#+
                }
                else
                {
#>
                value.<#= PropertyName(otherAssociation) #>.Add(this);
<#+
                }
#>
<#+
                // Generate code for assigning foreign key property values
                if (association.IsForeignKey)
                {
                    for (var i = 0; i < thisKeyColumns.Length; i++)
                    {
#>
                this.<#= FieldName(thisKeyColumns[i]) #> = value.<#= PropertyName(otherKeyColumnNames[i]) #>;
<#+
                    }
#>
            }
            else
            {
<#+
                    for (var i = 0; i < thisKeyColumns.Length; i++)
                    {
#>
                this.<#= FieldName(thisKeyColumns[i]) #> = default(<#= TypeName(thisKeyColumns[i]) #>);
<#+
                    }
                }
#>
            }

<#+
            }
#>
            this.SendPropertyChanged("<#= PropertyName(association) #>");
        }
    }
}
<#+
    }

    /// <summary>
    /// Renders Attach/Detach methods for a One-to-Many association
    /// </summary>
    private void RenderEntitySetActionMethods(Association association)
    {
        if (IsEntityRef(association))
        {
            return;
        }

        Association childAssociation = this.FindOtherAssociation(association);
        if (childAssociation == null)
        {
            throw new TransformationException(string.Format("Child association with ThisKey ({0}) doesn't exist.", association.OtherKey));
        }
#>

private void Attach<#= PropertyName(association) #>(<#= association.Type #> entity)
{
    this.SendPropertyChanging("<#= PropertyName(association) #>");
    entity.<#= PropertyName(childAssociation) #> = this;
}

private void Detach<#= PropertyName(association) #>(<#= association.Type #> entity)
{
    this.SendPropertyChanging("<#= PropertyName(association) #>");
    entity.<#= PropertyName(childAssociation) #> = null;
}
<#+
    }

    /// <summary>
    /// Renders property for a One-To-Many association
    /// </summary>
    private void RenderEntitySetProperty(Association association)
    {
#>
<#= AccessModifier(association) #> <#= InheritanceModifier(association) #>EntitySet<<#= association.Type #>> <#= PropertyName(association) #>
{
    get 
    {
<#+
        if (this.IsDataMember(association))
        {
#>
        if (this.serializing && !this.<#= FieldName(association) #>.HasLoadedOrAssignedValues)
        {
            return null;
        }

<#+
        }
#>
        return this.<#= FieldName(association) #>; 
    }

    set 
    { 
        this.<#= FieldName(association) #>.Assign(value); 
    }
}
<#+
    }

    /// <summary>
    /// Renders property definition for the specified <paramref name="association"/>
    /// </summary>
    private void RenderProperty(Association association)
    {
        this.WriteLine(string.Empty);
        this.RenderDataMemberAttribute(association);  // [DataMember(...)]
        this.RenderAssociationAttribute(association); // [Association(...)]
        if (IsEntityRef(association))
        {
            this.RenderEntityRefProperty(association);
        }
        else
        {
            this.RenderEntitySetProperty(association);
        }
    }

    /// <summary>
    /// Renders property definition for the specified <paramref name="column"/>
    /// </summary>
    private void RenderProperty(Column column)
    {
        this.WriteLine(string.Empty);
        this.RenderDataMemberAttribute(column); // [DataMember(...)]
        this.RenderColumnAttribute(column);     // [Column(...)]
#>
<#= AccessModifier(column) #> <#= InheritanceModifier(column) #><#= TypeName(column) #> <#= PropertyName(column) #>
{
    get
    {
        return this.<#= FieldName(column) #>;
    }

<#+
        // Generate property change notification code if table has primary key
        if (this.tableHasPrimaryKey)
        {
#>
    set
    {
        if (this.<#= FieldName(column) #> != value)
        {
<#+
            Association foreignKey = this.FindForeignKey(column);
            if (foreignKey != null)
            {
#>
            if (this.<#= FieldName(foreignKey) #>.HasLoadedOrAssignedValue)
            {
                throw new ForeignKeyReferenceAlreadyHasValueException();
            }
<#+
            }
#>
            this.On<#= PropertyName(column) #>Changing(value);
            this.SendPropertyChanging("<#= PropertyName(column) #>");
            this.<#= FieldName(column) #> = value;
            this.SendPropertyChanged("<#= PropertyName(column) #>");
            this.On<#= PropertyName(column) #>Changed();
        }
    }
<#+
        }
        else
        {
#>
    set
    {
        this.<#= FieldName(column) #> = value;
    }
<#+
        }
#>
}
<#+
    }

    /// <summary>
    /// Renders PropertyChange events
    /// </summary>
    private void RenderPropertyChangeEvents()
    {
        if (this.tableHasPrimaryKey && this.BaseTypes.Length == 0)
        {
#>

public event PropertyChangingEventHandler PropertyChanging;

public event PropertyChangedEventHandler PropertyChanged;
<#+
        }
    }

    /// <summary>
    /// Renders PropertyChange methods
    /// </summary>
    private void RenderPropertyChangeMethods()
    {
        if (this.tableHasPrimaryKey && this.BaseTypes.Length == 0)
        {
            string modifier;
            if (!this.Type.ModifierSpecified || this.Type.Modifier == ClassModifier.Abstract)
            {
                modifier = "protected virtual";
            }
			else // this.Type.Modifier == ClassModifier.Sealed
			{
				modifier = "private";
			}
#>

<#= modifier #> void SendPropertyChanging(string propertyName)
{
    if (this.PropertyChanging != null)
    {
        this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
    }
}

<#= modifier #> void SendPropertyChanged(string propertyName)
{
    if (this.PropertyChanged != null)
    {
        this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
}
<#+
        }
    }

    /// <summary>
    /// Generates a boolean field used as a flag to control serialization of 
    /// </summary>
    private void RenderSerializationField()
    {
        if (this.typeHasSerializableAssociation)
        {
#>

private bool serializing;
<#+
        }
    }

    /// <summary>
    /// Generates methods that receive serialization notifications
    /// </summary>
    private void RenderSerializationMethods()
    {
        if (this.typeHasSerializableAssociation)
        {
#>

[OnSerializing]
[EditorBrowsableAttribute(EditorBrowsableState.Never)]
internal void OnSerializing(StreamingContext context)
{
	this.serializing = true;
}

[OnSerialized]
[EditorBrowsableAttribute(EditorBrowsableState.Never)]
internal void OnSerialized(StreamingContext context)
{
	this.serializing = false;
}
<#+
        }
    }

    /// <summary>
    /// Renders [Table] attribute for the data class if it is mapped to a table.
    /// </summary>
    private void RenderTableAttribute()
    {
        if (this.BaseTypes.Length == 0 && !string.IsNullOrEmpty(this.Table.Name))
        {
            this.WriteLine("[Table(Name = \"{0}\")]", this.Table.Name);
        }
    }

    /// <summary>
    /// Renders conditional using directives
    /// </summary>
    private void RenderUsingDirectives()
    {
        if (this.IsDataContract(this.Type))
        {
            this.WriteLine("using System.Runtime.Serialization;");

            VSLangProj.VSProject project = (VSLangProj.VSProject)TransformationContext.Project.Object;
            project.References.Add("System.Runtime.Serialization");
        }
    }

    /// <summary>
    /// Converts the specified enum value to C# access modifier ("protected", "private", etc.)
    /// </summary>
    private static string ToCSharp(AccessModifier accessModifier)
    {
        if (accessModifier == GeneratedTextTransformation.AccessModifier.ProtectedInternal)
            return "protected internal";
        else
            return accessModifier.ToString().ToLower();
    }

    /// <summary>
    /// Converts the specified enum value to C# inheritance modifier ("new", "override", etc.)
    /// </summary>
    private static string ToCSharp(MemberModifier modifier, bool specified)
    {
        if (specified)
        {
            if (modifier == MemberModifier.NewVirtual)
                return "new virtual ";
            else
                return modifier.ToString().ToLower() + " ";
        }

        // When "None" was selected in the designer
        return string.Empty;
    }

    /// <summary>
    /// Returns type of the specified <paramref name="column"/>, converted to a built-in C# type if possible.
    /// </summary>
    private static string TypeName(Column column)
    {
        // Use built-in C# type, if possible
        string typeName = CSharpTypeName(column.Type);
        if (column.CanBeNull) // If column allows null values
        {
            // Determine if the type is a value or a reference
            string clrName = ClrTypeName(column.Type);
            System.Type type = System.Type.GetType(clrName);

            // If the type is defined outside of mscorlib assembly
            if (type == null)
            {
                // Try to find it in the other assemblies
                foreach (System.Reflection.Assembly assembly in System.AppDomain.CurrentDomain.GetAssemblies())
                {
                    type = assembly.GetType(clrName);
                    if (type != null)
                    {
                        break;
                    }
                }
            }

            // Unless we know with certainty that column type is a reference
            if (type == null || type.IsValueType)
            {
                // Assume it's a value type and use a nullable type
                typeName += "?";
            }
        }

        return typeName;
    }
}
#>
