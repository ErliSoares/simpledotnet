#summary Customized localized configuration description

= Introduction =

Simple.NET implements its own configuration system. Relying on XML standard, the framework provides a elegant way to write configuration definitions. All the configuration is automatically localizable. You don't have even to explicitly tell to configuration manager which location you want.

= Sample =

Suppose it's need to store a string and an integer inside a XML file. The XML structure will look like this:

{{{
<myConfig>
  <someInt>42</someInt>
  <someString>forty-two</someString>
</myConfig>
}}}

Then, to handle this in an OO model, all you should do is to create a configuration class that extends `ConfigElement`, or `ConfigRoot<T>`.

In this case, this class should look like:

{{{
[DefaultFile("MyConfig.config")]
public class MyConfig : ConfigRoot<MyConfig>
{
    [ConfigElement("someInt", Required=true)]
    public int SomeInt { get; set; }

    [ConfigElement("someString", Default="someDefaultValue")]
    public string SomeString { get; set; }
}
}}}

This way, the only thing you need to get the configuration is to call:
{{{
MyConfig config = MyConfig.Get()
}}}

= Localized configuration =
== How? ==
If you want to localize your configurations, the only thing you need is to move the tags you want to a *localized for* tag.

{{{
<myConfig>
  <someInt>42</someInt>
  <someString>forty-two</someString>

  <localized for="WhateverLand">
    <someString>forty-one-plus-one</someString>
  </localized>

  <localized for="Brazil">
    <someString>quarenta-e-dois</someString>
  </localized>
</myConfig>
}}}

You don't have to modify your code. But you may question "how can the configuration pattern know which is the location I want?".

You can define it in two ways. The first is explicitly tell which location you want to load.
{{{
MyConfig config = MyConfig.Get("Brazil");
}}}

But you can also do this more generically, creating a Localization Provider.

== Localization Providers ==

A localization provider is a class that implements `ILocalizationProvider` interface.
{{{
public interface ILocalizationProvider
{
    string GetLocalization(Type type);
}
}}}

Simple.NET comes with two default implementations: `NopLocalizationProvider` and `ThreadCultureLocalizationProvider`. Very intuitive.

You can also define your own Localization Provider.

=== How to use a Localization Provider ===

In order to use a provider, you must decorate either the calling method, class or assembly with `LocalizationProviderAttribute`. Then, all `ConfigRoot.Get()` calls will try to query the localization in the defined class.

For example, if in `AssemblyInfo.cs` file, inside Properties folder of the project, there is a line:
{{{
[assembly: LocalizationProvider(typeof(ThreadCultureLocalizationProvider))]
}}}

The current thread culture will be the default localization provider for config calls. But, if in a class inside this assembly, it is decorated this way:
{{{
[LocalizationProvider(typeof(NopLocalizationProvider))]
class Program
{
    static void Main(string[] args)
    {
}}}

Then, all calls inside this class will use `NopLocalizationProvider`. And so on.

The configuration provider tries to get the localization provider in the following order, using the first defined.

  # in the calling method
  # in the calling class
  # in the calling assembly

_Note: if a method is decorated with `LocalizationProviderIgnoreAttribute`, then it'll be skipped in this search_

= Complex objects =

XML is hierarhycal. This configuration pattern is also.

There are basically three types that uses XML hierarchy: complex elements, lists, dictionaries.

== Complex elements ==

In XML you can write:
{{{
<element>
  <childElement>
    <childChildElement/>
  </childElement>
</element>
}}}

Simple.NET considers any class that extends ConfigElement as a complex type. So, to map the XML above, the class should be:

{{{
public class ChildElement : ConfigElement {
    [ConfigElement("childChildElement")]
    public string ChildChild { get; set; }
}

public class Element : ConfigElement {
    [ConfigElement("childElement")]
    public ChildElement Child { get; set; }
}
}}}

== Lists ==

To use a List inside configuration, all you should do is to include a property with type implementing `IList<T>` interface. The simplest way is to


= Supported Types =

Simple.NET supports many system types, and also allows the developer to define its own types. By default, the supported types are:

  * All classes and structs that implements `IConvertible` interface. (int, string, double, etc.)
  * `Nullable<T>`, for all T : `IConvertible`
  * Enumerations 
  * Any class that implements `IList<T>`, for all T that can be handled
  * Any class that implements `IDictionary<K,V>`, for all K : `IConvertible` and V that can be handled
  * Byte arrays (that must be stored as Base64 in XML files)
  * Complex types (i.e., any class that extends ConfigElement)

= Real sample =

XML:
{{{
<?xml version="1.0" encoding="utf-8" ?>
<simpleLibrary>
  <business>
    <interfaceAssembly>Sample.BusinessInterface</interfaceAssembly>
    <serverAssembly>Sample.BusinessServer</serverAssembly>
  </business>
  <serviceModel>
    <defaultBaseAddress>http://localhost:9001/</defaultBaseAddress>
    <serviceConfigurator type="SimpleLibrary.ServiceModel.SingletonServiceConfigurator, SimpleLibraryBase"/>
    <serviceConfigurator type="SimpleLibrary.ServiceModel.ErrorBehaviorServiceConfigurator, SimpleLibraryBase"/>
    <serviceConfigurator type="SimpleLibrary.ServiceModel.DebugServiceConfigurator, SimpleLibraryBase" enabled="true"/>
    <serviceConfigurator type="SimpleLibrary.ServiceModel.MetadataBehaviorServiceConfigurator, SimpleLibraryBase">
      <address>mex</address>
      <httpGetEnabled>true</httpGetEnabled>
    </serviceConfigurator>

    <defaultEndpoint>
      <bindingNameRef>_DefaultBinding</bindingNameRef>
      <bindingType>System.ServiceModel.WSHttpBinding, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</bindingType>
      <address></address>

      <endpointConfigurator type="SimpleLibrary.ServiceModel.DataContractConfigurator, SimpleLibraryBase"/>
      <endpointConfigurator type="SimpleLibrary.ServiceModel.DefaultFaultsConfigurator, SimpleLibraryBase"/>
    </defaultEndpoint>

    <additionalEndpoints/>
  </serviceModel>
  <dataConfig>
    <nhibernateConfigFile>NHibernate.config</nhibernateConfigFile>
  </dataConfig>
</simpleLibrary>
}}}

Classes:

{{{
[DefaultFile("SimpleLibrary.config", false)]
public class SimpleLibraryConfig : ConfigRoot<SimpleLibraryConfig>
{
    [ConfigElement("business", Required = true)]
    public BusinessElement Business { get; set; }

    [ConfigElement("serviceModel", Required = true)]
    public ServiceModelElement ServiceModel { get; set; }

    [ConfigElement("dataConfig", Default = InstanceType.New)]
    public DataConfigElement DataConfig { get; set; }
}

public class BusinessElement : ConfigElement
{
    [ConfigElement("interfaceAssembly", Required = true)]
    public string InterfaceAssembly { get; set; }

    [ConfigElement("serverAssembly", Required = true)]
    public string ServerAssembly { get; set; }
}

public class ConfiguratorElement : PlainXmlConfigElement
{
    [ConfigElement("type", Required = true)]
    public string Type { get; set; }

    [ConfigElement("runOnlyAtServer", Default = false)]
    public bool RunOnlyAtServer { get; set; }
}

public class DataConfigElement : ConfigElement
{
    [ConfigElement("nhibernateConfigFile", Default = "NHibernate.config")]
    public string NHibernateConfigFile { get; set; }
}

public class ServiceModelElement : ConfigElement
{
    [ConfigElement("defaultEndpoint", Required = true)]
    public EndpointElement DefaultEndpoint { get; set; }

    [ConfigElement("endpoint")]
    [ConfigAcceptsParent("additionalEndpoints")]
    public List<EndpointElement> Endpoints { get; set; }

    [ConfigElement("serviceConfigurator")]
    public List<ConfiguratorElement> ServiceConfigurators { get; set; }

    [ConfigElement("defaultBaseAddress", Required = true)]
    public string DefaultBaseAddress { get; set; }
}
}}}