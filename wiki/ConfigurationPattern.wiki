#summary Customized localized configuration description


= Introduction =

Simple.NET implements it's own configuration system. Relying on XML standard, the framework provides a elegant way to write configuration definitions. All the configuration is automatically localizable. You don't have even to explicitly tell to configuration manager which location you want.

= Sample =

Suppose it's need to store a string and an integer inside a XML file. The XML structure will look like this:

{{{
<myConfig>
  <someInt>42</someInt>
  <someString>forty-two</someString>
</myConfig>
}}}

Then, to handle this in an OO model, all you should do is to create a configuration class that extends ConfigElement, or ConfigRoot.

In this case, this class should look like:

{{{
[DefaultFile("MyConfig.config")]
public class MyConfig : ConfigRoot<MyConfig>
{
    [ConfigElement("someInt", Required=true)]
    public int SomeInt { get; set; }

    [ConfigElement("someString", Default="someDefaultValue")]
    public string SomeString { get; set; }
}
}}}

This way, the only thing you need to get the configuration is to call:
{{{
MyConfig config = MyConfig.Get()
}}}

= Localized configuration =
== How? ==
If you want to localize your configurations, the only thing you need is to move the tags you want to a *localized for* tag.

{{{
<myConfig>
  <someInt>42</someInt>
  <someString>forty-two</someString>

  <localized for="WhateverLand">
    <someString>forty-one-plus-one</someString>
  </localized>

  <localized for="Brazil">
    <someString>quarenta-e-dois</someString>
  </localized>
</myConfig>
}}}

You don't have to modify your code. But you may question "how can the configuration pattern know which is the location I want?".

You can define it in two ways. The first is explicitly tell which location you want to load.
{{{
MyConfig config = MyConfig.Get("Brazil");
}}}

But you can also do this more generically, creating a Localization Provider.

== Localization Providers ==

A localization provider is a class that implements ILocalizationProvider interface.
{{{
public interface ILocalizationProvider
{
    string GetLocalization(Type type);
}
}}}

Simple.NET comes with two default implementations: NopLocalizationProvider and ThreadCultureLocalizationProvider. Very intuitive.

You can also define your own Localization Provider.

=== How to use a Localization Provider ===

In order to use a provider, you must decorate either the calling method, class or assembly with LocalizationProviderAttribute. Then, all ConfigRoot.Get() calls will try to query the localization in the defined class.

For example, if in AssemblyInfo.cs file, inside Properties folder of the project, there is a line:
{{{
[assembly: LocalizationProvider(typeof(ThreadCultureLocalizationProvider))]
}}}

The current thread culture will be the default localization provider for config calls. But, if in a class inside this assembly, it is decorated this way:
{{{
[LocalizationProvider(typeof(NopLocalizationProvider))]
class Program
{
    static void Main(string[] args)
    {
}}}

Then, all calls inside this class will use NopLocalizationProvider. And so on.

The configuration provider tries to get the localization provider in the following order, using the first defined.

# in the calling method
# in the calling class
# in the calling assembly

_Note: if a method is decorated with LocalizationProviderIgnoreAttribute, then it'll be skipped in this search_



