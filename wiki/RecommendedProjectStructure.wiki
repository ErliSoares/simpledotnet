#summary The best practices when creating a project with Simple.NET
#labels Featured,Phase-Implementation

=Introduction=

Simple.NET has been built to be as less invasive as possible. But some practices are recommended. Firstly, we'll try to explain what is needed. And, after that, what is recommended.

= What is needed =

Every Simple.NET solution must have at least three logical layers. In practice, they can be at the same project or not, your guess. Follows the description of each layer.

_Note: for information about Simple.NET assemblies, consult [LibraryAssemblies]_

== !BusinessInterface ==

_*This layer must reference:*_
  * _[LibraryAssemblies#SimpleLibraryCore SimpleLibraryCore] assembly_

This layer define contracts, either data contracts or business contracts. This layer defines e uncouples the interface from the implementation itself. It should contain two components.

=== Business Domain ===

Defines all the business entities. Note that one business entity doesn't need to be related to a database table. There can be an entity, for example, that maps to a query result. All entities must be decorated with DataContractAttribute, and all non-calculated properties must be decorated with DataMemberAttribute. NHibernate also requires that all properties are virtual.

eg:
{{{
[DataContract(Name="Employer", Namespace="BusinessInterface.Domain")]
public class Employer
{
    [DataMember]
    public virtual int Id { get; set; }
    public static PropertyName IdProperty = "Id";

    [DataMember]
    public virtual string Name { get; set; }
    public static PropertyName NameProperty = "Name";

    [DataMember]
    public virtual byte[] Version { get; set; }
    public static PropertyName VersionProperty = "Version";
}
}}}

All the `public static PropertyName` are optional, but they're highly recommended, to make the following syntax possible:

{{{
Filter filter = Employer.NameProperty.Eq("Google");
}}}

Believe. It's very handy.

=== Business Contracts ===

All the interfaces that defines business rules. Usually, they're interfaces that inherits from `IBaseRules<T>` where T is an entity. But it's not required. An interface must only be decorated with ServiceContractAttribute and MainContractAttribute, and all the interface members must be decorated with OperationContractAttribute.

{{{
[ServiceContract]
[MainContract]
public interface IEmployerRules : IBaseRules<Employer>
{
    [OperationContract]
    IList<Employer> GetAllEmployersWithSomeCondition();
}
}}}

==!BusinessServer==

_*This layer must reference:*_
  * _[LibraryAssemblies#BasicLibrary BasicLibrary] assembly_
  * _[LibraryAssemblies#SimpleLibraryCore SimpleLibraryCore] assembly_
  * _[LibraryAssemblies#SimpleLibraryServer SimpleLibraryServer] assembly_
  * _[#BusinessInterface BusinessInterface] assembly_

This layer must contain all business logic, including the data access. Most of the base methods (either rules and data access) are already implemented. It's just a matter of extending some classes.

===NHibernate mappings===

Inside this assembly, you must also create all NHibernate mapping files. You can do this many ways, but the most recommended is creating the .hbm.xml files as Embedded Resources to the project.

A sample follows:
{{{
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2">
  <class name="Sample.BusinessInterface.Domain.Employer,Sample.BusinessInterface" table="tb_employer" lazy="false" optimistic-lock="version" dynamic-update="true" >
    <id name="Id" column="id_employer" type="int">
      <generator class="native"/>
    </id>
    <version name="Version" column="version" type="SimpleLibrary.DataAccess.TimestampType,SimpleLibraryServer" generated="always" unsaved-value="null"/>
    <property type="string" length="120" name="Name" column="name" />
  </class>
</hibernate-mapping>
}}}

You can find great support on NHibernate community about how to create hbm files. More information about in http://www.hibernate.org

===!DataAccess===

There is no requirement on !DataAccess layer, but, often will be the best option to use `BaseDao<T>` class.

Doing that, can be useful implement the three main constructors of !BaseDao class. A sample follows:

{{{
public class EmployerDao : BaseDao<Employer>
{
    public EmployerDao () : base() { }
    public EmployerDao (ISession session) : base(session) { }
    public EmployerDao (BaseDao previousDao) : base(previousDao) { }
}
}}}

`BaseDao<T>` already have `ISession` instance, needed by NHibernate. This way, it's possible to get data in three main ways:

{{{
IQuery query = Session.CreateQuery("select e From Employer e"); //HQL Query
ISQLQuery sqlQuery = Session.CreateSQLQuery("select * from tb_employer"); //SQL Query
ICriteria criteria = Session.CreateCriteria(typeof(Employer)); //Crieria Query
}}}

All of them return data using `List<T>()` or `UniqueResult<T>()` methods.

_Note: when using ISQLQuery, you can define how the results will be transformed into entities using IResultTransformer instances. NHibernate provides simples transformers, but Simple.NET also offers two useful transformers. They're `TupleToPropertiesTransformer` and `TupleToConstructorTransformer`. They can be instantiated by using `SimpleTransformers.ByProperties<T>()` or `SimpleTransformers.ByConstructor<T>()` method._

===Rules===

Basically, for each business contract in [#BusinessInterface BusinessInterface] assembly, you must create a class that implements that contract. Note that if a contract extends `IBaseRules<T>`, you can make the implementing class to extend `BaseRules<T,D>` class, where T is entity type and D is the corresponding base data access class.

{{{
public class EmployerRules : BaseRules<Employer, EmployerDao>, IEmployerRules
{
    public virtual IList<Employer> GetAllEmployersWithSomeCondition() 
    {
        EmployerDao dao = GetDao();
        Filter filter = Employer.NameProperty.Eq("Google");
        return dao.ListByCriteria(CreateCriteriaByFilter(filter, OrderBy.Asc(Employer.IdProperty));
    }
}
}}}

Above sample is valid.

_Note: ALL methods inside a business rule MUST be virtual, in order to create a valid proxy. Note as well that it won't cause errors until you call the non-virtual methods._

==!UserInterface==

_*This layer must reference:*_
  * _[LibraryAssemblies#SimpleLibraryCore SimpleLibraryCore] assembly_
  * _[#BusinessInterface BusinessInterface] assembly_

All the knowledge that this layer must have about business are the contracts. The interface doesn't need to know anything about [#BusinessServer BusinessServer] capabilities, how it stores and retrieves data and etc. All it must do is instantiate contracts, this way:

{{{
IEmployerRules rules = RulesFactory.Create<IEmployerRules>();
}}}

You can also use the filters to call the base methods of `IBaseRules<T>` interface, like:

{{{
IList<Employer> list = rules.ListByFilter(Employer.NameProperty.Eq("Google"), OrderBy.None());
}}}

=What is recommended=

The most recommended architecture follows these layers seriously, creating one project for each layer. Sample project inside source code explains this well.

It contains:

  # Sample.!BusinessInterface project
  # Sample.!BusinessServer project
  # Sample.!UserInterface1 web project
  # Sample.!UserInterface2 console application project

You can also create a test project, that will contain all the unit tests required to test rules functionalities.